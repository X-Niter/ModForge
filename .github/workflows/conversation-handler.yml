name: Conversation Handler

on:
  issues:
    types: [opened, edited, reopened]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, edited, reopened]
  pull_request_review_comment:
    types: [created, edited]
  repository_dispatch:
    types: [autonomous-conversation, autonomous-followup]

# Prevent overlapping conversation handling
concurrency:
  group: conversation-${{ github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  process-conversation:
    runs-on: ubuntu-latest
    # Skip if the actor is the bot itself or GitHub Actions to prevent loops
    if: ${{ github.actor != 'github-actions[bot]' && github.actor != 'ModForge-AI[bot]' }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Git
        run: |
          git config --global user.name "ModForge Automation"
          git config --global user.email "automation@modforge.dev"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install openai gitpython requests
      
      - name: Determine conversation context
        id: context
        run: |
          # Figure out what kind of event triggered this workflow
          EVENT_TYPE="${{ github.event_name }}"
          
          if [[ "$EVENT_TYPE" == "issues" || "$EVENT_TYPE" == "issue_comment" ]]; then
            CONVERSATION_TYPE="issue"
            CONVERSATION_ID="${{ github.event.issue.number }}"
            echo "conversation_type=issue" >> $GITHUB_OUTPUT
            echo "conversation_id=$CONVERSATION_ID" >> $GITHUB_OUTPUT
            echo "is_stale=false" >> $GITHUB_OUTPUT
            echo "Processing issue #$CONVERSATION_ID"
            
          elif [[ "$EVENT_TYPE" == "pull_request" || "$EVENT_TYPE" == "pull_request_review_comment" ]]; then
            CONVERSATION_TYPE="pr"
            CONVERSATION_ID="${{ github.event.pull_request.number }}"
            echo "conversation_type=pr" >> $GITHUB_OUTPUT
            echo "conversation_id=$CONVERSATION_ID" >> $GITHUB_OUTPUT
            echo "is_stale=false" >> $GITHUB_OUTPUT
            echo "Processing PR #$CONVERSATION_ID"
            
          elif [[ "$EVENT_TYPE" == "repository_dispatch" ]]; then
            # Check which type of dispatch event
            DISPATCH_TYPE="${{ github.event.action }}"
            
            if [[ "$DISPATCH_TYPE" == "autonomous-conversation" || "$DISPATCH_TYPE" == "autonomous-followup" ]]; then
              PAYLOAD='${{ toJson(github.event.client_payload) }}'
              echo "Payload: $PAYLOAD"
              
              # Extract type and ID from the payload (issue or PR)
              CONVO_TYPE=$(echo $PAYLOAD | jq -r .type)
              CONVO_ID=$(echo $PAYLOAD | jq -r .id)
              
              if [[ "$CONVO_TYPE" != "null" && "$CONVO_ID" != "null" ]]; then
                echo "conversation_type=$CONVO_TYPE" >> $GITHUB_OUTPUT
                echo "conversation_id=$CONVO_ID" >> $GITHUB_OUTPUT
                
                # If it's a follow-up, mark as stale
                if [[ "$DISPATCH_TYPE" == "autonomous-followup" ]]; then
                  echo "is_stale=true" >> $GITHUB_OUTPUT
                else
                  echo "is_stale=false" >> $GITHUB_OUTPUT
                fi
                
                echo "Processing $CONVO_TYPE #$CONVO_ID from repository dispatch"
              else
                echo "Invalid payload in repository dispatch"
                exit 1
              fi
            else
              echo "Unknown repository dispatch type: $DISPATCH_TYPE"
              exit 1
            fi
            
          else
            echo "Unknown event type: $EVENT_TYPE"
            exit 1
          fi
      
      - name: Process conversation
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CONVERSATION_TYPE: ${{ steps.context.outputs.conversation_type }}
          CONVERSATION_ID: ${{ steps.context.outputs.conversation_id }}
          IS_STALE: ${{ steps.context.outputs.is_stale }}
        run: |
          python .github/scripts/process_conversation.py


```java
{content}
```

Focus on correctness, performance, and best practices. Provide the complete fixed code, not just the changes."""
              elif cmd_type == 'improve':
                  prompt = f"""You are an expert Java developer. Improve the quality of this code file while preserving its functionality:

```java
{content}
```

Focus on readability, maintainability, and performance. Provide the complete improved code, not just the changes."""
              elif cmd_type == 'document':
                  prompt = f"""You are an expert Java developer. Add comprehensive JavaDoc documentation to this code file:

```java
{content}
```

Include class-level docs, method docs, parameter descriptions, and return value descriptions. Provide the complete documented code."""
              elif cmd_type == 'refactor':
                  prompt = f"""You are an expert Java developer. Refactor this code to improve its structure while preserving functionality:

```java
{content}
```

Focus on code organization, design patterns, and maintainability. Provide the complete refactored code."""
              else:
                  return f"Unknown modification command: {cmd_type}"
              
              # Generate modified code using OpenAI
              try:
                  response = client.chat.completions.create(
                      model="gpt-4",
                      messages=[
                          {"role": "system", "content": f"You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project. Your task is to {cmd_type} code."},
                          {"role": "user", "content": prompt}
                      ],
                      temperature=0.2,
                      max_tokens=4000
                  )
                  
                  modified_code = response.choices[0].message.content
                  
                  # Extract code from markdown code block if present
                  code_match = re.search(r'```(?:java)?\n(.*?)\n```', modified_code, re.DOTALL)
                  if code_match:
                      modified_code = code_match.group(1)
                  
                  # Write the modified code back to the file
                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.write(modified_code)
                  
                  # Commit and push the changes
                  subprocess.run(['git', 'add', file_path], check=True)
                  subprocess.run(['git', 'commit', '-m', f"{cmd_type.capitalize()}: {os.path.basename(file_path)} [ModForge AI]"], check=True)
                  subprocess.run(['git', 'push', 'origin', branch_name], check=True)
                  
                  # Create a pull request
                  pr_data = {
                      'title': f"{cmd_type.capitalize()}: {os.path.basename(file_path)}",
                      'body': f"""This PR was created by ModForge AI in response to a /{cmd_type} command.

## Changes Made
- {cmd_type.capitalize()}d `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                      'head': branch_name,
                      'base': 'main',
                      'maintainer_can_modify': True
                  }
                  
                  response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
                  
                  if response.status_code == 201:
                      pr_url = response.json().get('html_url')
                      return f"""I've {cmd_type}d `{os.path.basename(file_path)}` and created a pull request:

[View Pull Request]({pr_url})

The changes include:
- {get_modification_summary(cmd_type, file_path, content, modified_code)}

Please review the PR and merge it if the changes look good."""
                  else:
                      return f"I've {cmd_type}d `{os.path.basename(file_path)}`, but couldn't create a PR. Error: {response.status_code} {response.text}"
              
              except Exception as e:
                  return f"Error {cmd_type}ing {file_path}: {str(e)}"

          def get_modification_summary(cmd_type, file_path, old_content, new_content):
              """Generate a summary of the changes made"""
              if cmd_type == 'document':
                  # Count added documentation lines
                  old_lines = old_content.count('\n')
                  new_lines = new_content.count('\n')
                  old_javadoc_lines = old_content.count('/**')
                  new_javadoc_lines = new_content.count('/**')
                  
                  return f"Added documentation to {new_javadoc_lines - old_javadoc_lines} classes/methods, increasing the file from {old_lines} to {new_lines} lines"
              
              elif cmd_type == 'fix':
                  # Look for removed potential bug patterns
                  null_checks_added = new_content.count('if (') - old_content.count('if (')
                  exception_handling_added = new_content.count('catch') - old_content.count('catch')
                  
                  return f"Fixed potential issues including {null_checks_added} new null checks and {exception_handling_added} improved exception handlers"
              
              elif cmd_type == 'improve' or cmd_type == 'refactor':
                  # Count structural changes
                  old_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', old_content))
                  new_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', new_content))
                  
                  changes = []
                  if new_methods > old_methods:
                      changes.append(f"Refactored code into {new_methods - old_methods} additional methods")
                  elif new_methods < old_methods:
                      changes.append(f"Consolidated {old_methods - new_methods} methods")
                  
                  if new_content.count('{') < old_content.count('{'):
                      changes.append("Reduced code complexity")
                  
                  if not changes:
                      changes.append("Improved code structure and readability")
                  
                  return "; ".join(changes)
              
              return "Made changes as requested"

          def execute_feature_addition(cmd_args, branch_name):
              """Add a new feature to a component"""
              feature = cmd_args.get('feature')
              target = cmd_args.get('target')
              
              if not feature or not target:
                  return "Invalid arguments for add command. Format: /add [feature] to [target]"
              
              # Find the target file
              file_path = find_file(target)
              
              # If target file doesn't exist, we might need to create a new file
              if not file_path:
                  # Check if it looks like a package.class specification
                  if '.' in target:
                      parts = target.split('.')
                      class_name = parts[-1]
                      package_path = '/'.join(parts[:-1])
                      
                      # Try to find the package directory
                      package_exists = False
                      for root, dirs, _ in os.walk('.'):
                          if any(skip in root for skip in ['/build/', '/.git/', '/.github/']):
                              continue
                          
                          package_dir = os.path.join(root, package_path)
                          if os.path.exists(package_dir):
                              package_exists = True
                              file_path = os.path.join(package_dir, f"{class_name}.java")
                              break
                      
                      if not package_exists:
                          # Create directory structure if needed
                          os.makedirs(os.path.join('src/main/java', package_path), exist_ok=True)
                          file_path = os.path.join('src/main/java', package_path, f"{class_name}.java")
                  else:
                      # Assume it's a new file in the current directory
                      file_path = f"{target}.java"
              
              # Check if we need to create a new file or modify an existing one
              new_file = not os.path.exists(file_path)
              
              if new_file:
                  # Generate a new file with the feature implemented
                  prompt = f"""Create a new Java class for an IntelliJ plugin that implements the following feature: {feature}

Use proper JavaDoc, follow IntelliJ platform conventions, and include all necessary imports.
The file path will be: {file_path}

If the file path suggests a package, include the appropriate package declaration.
Make the class comprehensive and complete, ready to be integrated into the project."""
                  
                  try:
                      response = client.chat.completions.create(
                          model="gpt-4",
                          messages=[
                              {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                              {"role": "user", "content": prompt}
                          ],
                          temperature=0.2,
                          max_tokens=3000
                      )
                      
                      new_code = response.choices[0].message.content
                      
                      # Extract code from markdown code block if present
                      code_match = re.search(r'```(?:java)?\n(.*?)\n```', new_code, re.DOTALL)
                      if code_match:
                          new_code = code_match.group(1)
                      
                      # Ensure directory exists
                      os.makedirs(os.path.dirname(file_path), exist_ok=True)
                      
                      # Write the code to the file
                      with open(file_path, 'w', encoding='utf-8') as f:
                          f.write(new_code)
                      
                      # Commit and push the changes
                      subprocess.run(['git', 'add', file_path], check=True)
                      subprocess.run(['git', 'commit', '-m', f"Add: {feature} in {os.path.basename(file_path)} [ModForge AI]"], check=True)
                      subprocess.run(['git', 'push', 'origin', branch_name], check=True)
                      
                      # Create a pull request
                      pr_data = {
                          'title': f"Add: {feature}",
                          'body': f"""This PR was created by ModForge AI in response to an /add command.

## Feature Added
Added "{feature}" by creating a new file: `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                          'head': branch_name,
                          'base': 'main',
                          'maintainer_can_modify': True
                      }
                      
                      response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
                      
                      if response.status_code == 201:
                          pr_url = response.json().get('html_url')
                          return f"""I've created a new file `{os.path.basename(file_path)}` implementing the "{feature}" feature.

[View Pull Request]({pr_url})

The new file includes:
- Full implementation of the requested feature
- Proper JavaDoc documentation
- All necessary imports and dependencies

Please review the PR and merge it if the implementation looks good."""
                      else:
                          return f"I've created a new file for the feature, but couldn't create a PR. Error: {response.status_code} {response.text}"
                  
                  except Exception as e:
                      return f"Error creating new file for feature: {str(e)}"
    else:
              # Modify existing file to add the feature
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      content = f.read()
                      
                  prompt = f"""Add the following feature to this existing Java class: {feature}

Current code:
```java
{content}
```

Make sure to:
1. Maintain the existing code structure and functionality
2. Include proper JavaDoc for new methods
3. Add any necessary imports
4. Make the changes seamlessly integrate with the existing code

Provide the complete updated code."""
                  
                  response = client.chat.completions.create(
                      model="gpt-4",
                      messages=[
                          {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                          {"role": "user", "content": prompt}
                      ],
                      temperature=0.2,
                      max_tokens=3000
                  )
                  
                  modified_code = response.choices[0].message.content
                  
                  # Extract code from markdown code block if present
                  code_match = re.search(r'```(?:java)?\n(.*?)\n```', modified_code, re.DOTALL)
                  if code_match:
                      modified_code = code_match.group(1)
                  
                  # Write the modified code back to the file
                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.write(modified_code)
                  
                  # Commit and push the changes
                  subprocess.run(['git', 'add', file_path], check=True)
                  subprocess.run(['git', 'commit', '-m', f"Add: {feature} to {os.path.basename(file_path)} [ModForge AI]"], check=True)
                  subprocess.run(['git', 'push', 'origin', branch_name], check=True)
                  
                  # Create a pull request
                  pr_data = {
                      'title': f"Add: {feature}",
                      'body': f"""This PR was created by ModForge AI in response to an /add command.

## Feature Added
Added "{feature}" to `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                      'head': branch_name,
                      'base': 'main',
                      'maintainer_can_modify': True
                  }
                  
                  response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
                  
                  if response.status_code == 201:
                      pr_url = response.json().get('html_url')
                      
                      # Generate a summary of what was added
                      old_lines = content.count('\n')
                      new_lines = modified_code.count('\n')
                      old_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', content))
                      new_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', modified_code))
                      
                      return f"""I've added the "{feature}" feature to `{os.path.basename(file_path)}`.

[View Pull Request]({pr_url})

The changes include:
- Added {new_methods - old_methods} new methods
- Added {new_lines - old_lines} lines of code
- Integrated with existing functionality

Please review the PR and merge it if the implementation looks good."""
                  else:
                      return f"I've added the feature to the file, but couldn't create a PR. Error: {response.status_code} {response.text}"
                      
              except Exception as e:
                  return f"Error adding feature to {file_path}: {str(e)}"

def execute_code_analysis(target):
    """Perform deep analysis of code or components"""
    # If target is a specific file
    file_path = find_file(target)
    if file_path:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            prompt = f"""Perform a deep analysis of this Java file:

```java
{content}
```

Provide a comprehensive analysis including:
1. Purpose and responsibilities of the class
2. Key methods and their functionality
3. Design patterns used
4. Potential improvements
5. Code quality assessment
6. Integration with the rest of the system

Format your analysis with clear sections and highlight important findings."""
            
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )
            
            analysis = response.choices[0].message.content
            return f"""# Analysis of `{os.path.basename(file_path)}`

{analysis}

Would you like me to implement any of the suggested improvements? Just let me know which ones interest you most."""
                
        except Exception as e:
            return f"Error analyzing {file_path}: {str(e)}"
    
    # If target is a more general component or concept
    else:
        # Find relevant files
        related_files = []
        search_term = target.lower()
        
        for root, _, files in os.walk('.'):
            if any(skip in root for skip in ['/build/', '/.git/', '/.github/']):
                continue
                
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read().lower()
                            if search_term in content or search_term in file.lower() or search_term in root.lower():
                                related_files.append(file_path)
                    except:
                        pass
        
        if not related_files:
            return f"I couldn't find any files related to '{target}'. Please provide a more specific target or a direct file path."
        
        # Limit to avoid overwhelming the API
        related_files = related_files[:5]
        
        # Compile file contents
        file_contents = {}
        for file_path in related_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    # Truncate very large files
                    content = f.read(10000)
                    file_contents[file_path] = content
            except:
                pass
        
        prompt = f"""Analyze the following set of related Java files that implement or relate to '{target}':

"""
        
        for file_path, content in file_contents.items():
            prompt += f"""
## {os.path.basename(file_path)}
```java
{content}
```

"""
        
        prompt += """
Provide a comprehensive analysis of this component/feature including:
1. Overall architecture and design
2. Key classes and their responsibilities
3. How the components interact
4. Potential areas for improvement
5. Best practices implemented
6. Any concerns or technical debt

Format your analysis with clear sections and highlight important findings."""
        
        try:
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )
            
            analysis = response.choices[0].message.content
            return f"""# Analysis of '{target}'

{analysis}

Analyzed {len(file_contents)} files related to this component. Would you like me to implement any of the suggested improvements or analyze any aspect in more detail?"""
                
        except Exception as e:
            return f"Error analyzing '{target}': {str(e)}"

def execute_code_explanation(target):
    """Explain how specified code works"""
    file_path = find_file(target)
    if not file_path:
        return f"Could not find the target file: {target}. Please provide a valid file path or class name."
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        prompt = f"""Explain how this code works in a clear, educational way:

```java
{content}
```

Focus on:
1. The overall purpose of the class/module
2. How key methods work and interact
3. Important algorithms or patterns
4. How it integrates with the rest of the system
5. Any non-obvious or complex parts

Explain as if to a developer who is new to the project but familiar with Java and IntelliJ plugin development."""
        
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=3000
        )
        
        explanation = response.choices[0].message.content
        return f"""# Explanation of `{os.path.basename(file_path)}`

{explanation}

Is there any specific part of this code you'd like me to explain in more detail?"""
            
    except Exception as e:
        return f"Error explaining {file_path}: {str(e)}"

def execute_implementation(cmd_args, history, branch_name):
    """Implement suggestions from a previous issue"""
    # Find the suggestions in the conversation history
    suggestions = []
    
    for entry in history:
        content = entry.get('content', '')
        
        # Look for suggested improvements pattern
        suggestion_blocks = re.findall(r'(?:^|\n)(\d+\.\s+.*?)(?=\n\d+\.\s+|\n\n|$)', content, re.DOTALL)
        if suggestion_blocks:
            for i, block in enumerate(suggestion_blocks, 1):
                suggestions.append((i, block.strip()))
    
    if not suggestions:
        return "I couldn't find any numbered suggestions in the conversation. Please provide specific instructions about what you'd like me to implement."
    
    # Determine which suggestions to implement
    to_implement = []
    
    if isinstance(cmd_args, dict):
        if cmd_args.get('all'):
            to_implement = suggestions
        elif 'indices' in cmd_args:
            indices = cmd_args.get('indices', [])
            to_implement = [s for s in suggestions if s[0] in indices]
    
    if not to_implement:
        return f"No valid suggestions identified for implementation. Available suggestions are numbered 1-{len(suggestions)}."
    
    # Implement each suggestion
    implemented = []
    for idx, suggestion in to_implement:
        try:
            # Extract target file if mentioned
            file_match = re.search(r'(?:in|to|for)\s+[`"]?([\w./]+\.java)[`"]?', suggestion)
            target_file = file_match.group(1) if file_match else None
            
            if not target_file:
                # Try to infer from the context
                for entry in history:
                    content = entry.get('content', '')
                    file_matches = re.findall(r'[`"]?([\w./]+\.java)[`"]?', content)
                    if file_matches:
                        potential_targets = []
                        for match in file_matches:
                            file_path = find_file(match)
                            if file_path:
                                potential_targets.append(file_path)
                        
                        if potential_targets:
                            target_file = os.path.basename(potential_targets[0])
            
            if not target_file:
                implemented.append((idx, suggestion, "Could not identify target file", False))
                continue
            
            file_path = find_file(target_file)
            if not file_path:
                implemented.append((idx, suggestion, f"Could not find file: {target_file}", False))
                continue
            
            # Read the file
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Generate implementation
            prompt = f"""Implement this suggestion in the following code:

Suggestion: {suggestion}

Current code:
```java
{content}
```

Make the necessary changes to implement the suggestion. Provide the complete updated code."""
            
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.2,
                max_tokens=3000
            )
            
            modified_code = response.choices[0].message.content
            
            # Extract code from markdown code block if present
            code_match = re.search(r'```(?:java)?\n(.*?)\n```', modified_code, re.DOTALL)
            if code_match:
                modified_code = code_match.group(1)
            
            # Write the modified code back to the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(modified_code)
            
            # Add and commit the change
            subprocess.run(['git', 'add', file_path], check=True)
            subprocess.run(['git', 'commit', '-m', f"Implement suggestion #{idx}: {suggestion[:50]}... [ModForge AI]"], check=True)
            
            implemented.append((idx, suggestion, file_path, True))
            
        except Exception as e:
            implemented.append((idx, suggestion, f"Error: {str(e)}", False))
    
    # Push changes if any were successful
    if any(i[3] for i in implemented):
        try:
            subprocess.run(['git', 'push', 'origin', branch_name], check=True)
            
            # Create a PR
            pr_data = {
                'title': f"Implement suggestions from #{conversation_id}",
                'body': f"""This PR was created by ModForge AI in response to an /implement command.

## Implemented Suggestions
{chr(10).join([f"- Suggestion #{i[0]}: {i[1][:100]}..." for i in implemented if i[3]])}

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                'head': branch_name,
                'base': 'main',
                'maintainer_can_modify': True
            }
            
            response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
            
            if response.status_code == 201:
                pr_url = response.json().get('html_url')
                result = f"I've implemented {sum(1 for i in implemented if i[3])} of {len(to_implement)} suggestions.\n\n[View Pull Request]({pr_url})\n\n"
            else:
                result = f"I've implemented {sum(1 for i in implemented if i[3])} of {len(to_implement)} suggestions, but couldn't create a PR. Error: {response.status_code}\n\n"
        except Exception as e:
            result = f"I've made changes but encountered an error: {str(e)}\n\n"
    else:
        result = "I couldn't implement any of the suggestions successfully.\n\n"
    
    # Report on each implementation
    result += "## Implementation Results\n\n"
    for idx, suggestion, outcome, success in implemented:
        if success:
            result += f"### ✅ Suggestion #{idx}\n{suggestion[:200]}...\n\nImplemented in `{os.path.basename(outcome)}`\n\n"
        else:
            result += f"### ❌ Suggestion #{idx}\n{suggestion[:200]}...\n\nFailed: {outcome}\n\n"
    
    return result

def execute_test_command(target, branch_name):
    """Create or run tests for a component"""
    file_path = find_file(target)
    if not file_path:
        return f"Could not find the target file: {target}. Please provide a valid file path or class name."
    
    # Determine if tests already exist
    test_file_name = os.path.basename(file_path).replace('.java', 'Test.java')
    test_dir = os.path.join('src/test/java')
    
    # Try to find existing test file
    existing_test = None
    for root, _, files in os.walk(test_dir):
        if test_file_name in files:
            existing_test = os.path.join(root, test_file_name)
            break
    
    if existing_test:
        # Run existing tests
        try:
            subprocess.run(['./gradlew', 'test', '--tests', f"*{test_file_name.replace('.java', '')}"], check=True)
            return f"I've run the existing tests for `{os.path.basename(file_path)}`. All tests passed."
        except subprocess.CalledProcessError as e:
            return f"I've run the existing tests for `{os.path.basename(file_path)}`, but some tests failed. Error: {str(e)}"
    
    # Create new tests
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Determine package from the file
        package_match = re.search(r'package\s+([\w.]+);', content)
        package = package_match.group(1) if package_match else ""
        
        # Create test directory
        if package:
            package_path = package.replace('.', '/')
            test_file_path = os.path.join(test_dir, package_path, test_file_name)
            os.makedirs(os.path.dirname(test_file_path), exist_ok=True)
        else:
            test_file_path = os.path.join(test_dir, test_file_name)
            os.makedirs(os.path.dirname(test_file_path), exist_ok=True)
        
        # Generate test code
        prompt = f"""Write JUnit tests for this Java class:

```java
{content}
```

Create comprehensive tests that cover:
1. All public methods
2. Edge cases and error conditions
3. Typical usage scenarios

Use JUnit 5 (Jupiter) syntax and follow best practices for unit testing.
Include mock objects where appropriate using Mockito.
Make the tests as complete and professional as possible."""
        
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,
            max_tokens=3000
        )
        
        test_code = response.choices[0].message.content
        
        # Extract code from markdown code block if present
        code_match = re.search(r'```(?:java)?\n(.*?)\n```', test_code, re.DOTALL)
        if code_match:
            test_code = code_match.group(1)
        
        # Write the test code to the file
        with open(test_file_path, 'w', encoding='utf-8') as f:
            f.write(test_code)
        
        # Commit and push the changes
        subprocess.run(['git', 'add', test_file_path], check=True)
        subprocess.run(['git', 'commit', '-m', f"Add tests for {os.path.basename(file_path)} [ModForge AI]"], check=True)
        subprocess.run(['git', 'push', 'origin', branch_name], check=True)
        
        # Create a pull request
        pr_data = {
            'title': f"Add tests for {os.path.basename(file_path)}",
            'body': f"""This PR was created by ModForge AI in response to a /test command.

## Added Tests
Tests for `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these tests and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
            'head': branch_name,
            'base': 'main',
            'maintainer_can_modify': True
        }
        
        response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
        
        if response.status_code == 201:
            pr_url = response.json().get('html_url')
            return f"""I've created tests for `{os.path.basename(file_path)}`.

[View Pull Request]({pr_url})

The test suite includes:
- {test_code.count('@Test')} test methods
- Coverage for main functionality
- Edge case testing

Please review the PR and merge it if the tests look good."""
        else:
            return f"I've created tests for `{os.path.basename(file_path)}`, but couldn't create a PR. Error: {response.status_code} {response.text}"
            
    except Exception as e:
        return f"Error creating tests for {file_path}: {str(e)}"

def generate_stale_followup(history):
    """Generate a follow-up for a stale conversation"""
    # Analyze the conversation to determine what's needed
    
    # Format the conversation history for the AI
    messages = [
        {"role": "system", "content": """You are the ModForge AI assistant checking on a conversation that hasn't had activity for a few days.

Use the same personality as a direct, casual, to-the-point developer. Sound like a real person checking back on something, not like an automated system or formal assistant. Your tone should be:
- Casual and friendly - like a colleague or friend checking in
- Direct and straightforward - get right to the point about any pending items
- Conversational but brief - don't apologize for the delay or be too formal
- Occasionally enthusiastic - use an exclamation point if appropriate

Structure your check-in message to:
1. Briefly mention you're checking back on the thread (don't be apologetic about it)
2. Directly reference anything specific that was pending or unresolved
3. Ask a direct question about what they want to do next
4. Keep it under 5 sentences total

Sound like a real developer following up, not an AI assistant."""}
    ]
    
    # Add conversation history
    for entry in history:
        role = "assistant" if entry.get('author') in ['github-actions[bot]', 'ModForge-AI[bot]', 'ModForge Automation'] else "user"
        messages.append({"role": role, "content": entry.get('content', '')})
    
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            temperature=0.8, # Higher temperature for more natural follow-ups
            max_tokens=1500
        )
        
        # Get current date for the follow-up message
        current_date = datetime.datetime.now().strftime("%B %d, %Y")
        
        followup_text = f"""## Quick follow-up ({current_date})

{response.choices[0].message.content}

_Automated check-in from the ModForge system_
"""
        return followup_text
        
    except Exception as e:
        print(f"Error generating stale follow-up: {str(e)}")
        return f"""## Quick follow-up

Hey, just checking if there's anything else needed on this thread? Let me know if you want me to take any action here or if we're all good.

_Automated check-in from the ModForge system_
"""

def main():
    # Fetch conversation history
    history = fetch_conversation_history()
    
    if not history:
        print("Failed to fetch conversation history")
        return
    
    # Handle stale conversation follow-up differently
    if is_stale:
        print("Processing stale conversation follow-up")
        response_text = generate_stale_followup(history)
        if response_text:
            post_response(response_text)
        return
    
    # Get the latest message (the one that triggered this workflow)
    latest_message = history[-1]
    latest_content = latest_message.get('content', '')
    
    # Check for commands in the message
    commands = detect_commands(latest_content)
    
    # Initialize response
    if commands:
        # Process the first command (we'll handle one at a time for now)
        cmd_type, cmd_args = commands[0]
        print(f"Processing command: {cmd_type} with args: {cmd_args}")
        
        response_text = execute_command(cmd_type, cmd_args, history)
    else:
        # Generate a conversational response
        response_text = generate_response(history)
    
    # Post the response
    if response_text:
        post_response(response_text)

if __name__ == "__main__":
    main()
          EOF

          # Execute the script
          python process_conversation.py
