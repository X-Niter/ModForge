name: Conversation Handler

on:
  issues:
    types: [opened, edited, reopened]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, edited, reopened]
  pull_request_review_comment:
    types: [created, edited]
  repository_dispatch:
    types: [autonomous-conversation, autonomous-followup]

# Prevent overlapping conversation handling
concurrency:
  group: conversation-${{ github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  process-conversation:
    runs-on: ubuntu-latest
    # Skip if the actor is the bot itself or GitHub Actions to prevent loops
    if: ${{ github.actor != 'github-actions[bot]' && github.actor != 'ModForge-AI[bot]' }}
    permissions:
      contents: write
      issues: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Git
        run: |
          git config --global user.name "ModForge Automation"
          git config --global user.email "automation@modforge.dev"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install openai gitpython requests
      
      - name: Determine conversation context
        id: context
        run: |
          # Figure out what kind of event triggered this workflow
          EVENT_TYPE="${{ github.event_name }}"
          
          if [[ "$EVENT_TYPE" == "issues" || "$EVENT_TYPE" == "issue_comment" ]]; then
            CONVERSATION_TYPE="issue"
            CONVERSATION_ID="${{ github.event.issue.number }}"
            echo "conversation_type=issue" >> $GITHUB_OUTPUT
            echo "conversation_id=$CONVERSATION_ID" >> $GITHUB_OUTPUT
            echo "is_stale=false" >> $GITHUB_OUTPUT
            echo "Processing issue #$CONVERSATION_ID"
            
          elif [[ "$EVENT_TYPE" == "pull_request" || "$EVENT_TYPE" == "pull_request_review_comment" ]]; then
            CONVERSATION_TYPE="pr"
            CONVERSATION_ID="${{ github.event.pull_request.number }}"
            echo "conversation_type=pr" >> $GITHUB_OUTPUT
            echo "conversation_id=$CONVERSATION_ID" >> $GITHUB_OUTPUT
            echo "is_stale=false" >> $GITHUB_OUTPUT
            echo "Processing PR #$CONVERSATION_ID"
            
          elif [[ "$EVENT_TYPE" == "repository_dispatch" ]]; then
            # Check which type of dispatch event
            DISPATCH_TYPE="${{ github.event.action }}"
            
            if [[ "$DISPATCH_TYPE" == "autonomous-conversation" || "$DISPATCH_TYPE" == "autonomous-followup" ]]; then
              PAYLOAD='${{ toJson(github.event.client_payload) }}'
              echo "Payload: $PAYLOAD"
              
              # Extract type and ID from the payload (issue or PR)
              CONVO_TYPE=$(echo $PAYLOAD | jq -r .type)
              CONVO_ID=$(echo $PAYLOAD | jq -r .id)
              
              if [[ "$CONVO_TYPE" != "null" && "$CONVO_ID" != "null" ]]; then
                echo "conversation_type=$CONVO_TYPE" >> $GITHUB_OUTPUT
                echo "conversation_id=$CONVO_ID" >> $GITHUB_OUTPUT
                
                # If it's a follow-up, mark as stale
                if [[ "$DISPATCH_TYPE" == "autonomous-followup" ]]; then
                  echo "is_stale=true" >> $GITHUB_OUTPUT
                else
                  echo "is_stale=false" >> $GITHUB_OUTPUT
                fi
                
                echo "Processing $CONVO_TYPE #$CONVO_ID from repository dispatch"
              else
                echo "Invalid payload in repository dispatch"
                exit 1
              fi
            else
              echo "Unknown repository dispatch type: $DISPATCH_TYPE"
              exit 1
            fi
            
          else
            echo "Unknown event type: $EVENT_TYPE"
            exit 1
          fi
      
      - name: Process conversation
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CONVERSATION_TYPE: ${{ steps.context.outputs.conversation_type }}
          CONVERSATION_ID: ${{ steps.context.outputs.conversation_id }}
          IS_STALE: ${{ steps.context.outputs.is_stale }}
        run: |
          # Create a Python script to process the conversation
          cat > process_conversation.py << 'EOF'
          import os
          import sys
          import json
          import re
          import requests
          import subprocess
          import random
          import time
          import datetime
          from pathlib import Path
          
          # Get environment variables
          openai_api_key = os.environ.get('OPENAI_API_KEY')
          github_token = os.environ.get('GITHUB_TOKEN')
          conversation_type = os.environ.get('CONVERSATION_TYPE')
          conversation_id = os.environ.get('CONVERSATION_ID')
          is_stale = os.environ.get('IS_STALE', 'false').lower() == 'true'
          repo = os.environ.get('GITHUB_REPOSITORY')

          # Validate required environment variables
          if not all([openai_api_key, github_token, conversation_type, conversation_id, repo]):
              print("Missing required environment variables")
              sys.exit(1)
          
          # Setup GitHub API
          api_url = f"https://api.github.com/repos/{repo}"
          headers = {
              'Authorization': f'token {github_token}',
              'Accept': 'application/vnd.github.v3+json'
          }
          
          # Import OpenAI with newer client library
          import openai
          client = openai.OpenAI(api_key=openai_api_key)

          # Define command patterns
          COMMAND_PATTERNS = {
              'fix': r'/fix\s+(?:"([^"]+)"|([^\s"]+))',
              'improve': r'/improve\s+(?:"([^"]+)"|([^\s"]+))',
              'document': r'/document\s+(?:"([^"]+)"|([^\s"]+))',
              'add': r'/add\s+(?:"([^"]+)"|([^\s"]+))\s+to\s+(?:"([^"]+)"|([^\s"]+))',
              'analyze': r'/analyze\s+(?:"([^"]+)"|([^\s"]+))',
              'explain': r'/explain\s+(?:"([^"]+)"|([^\s"]+))',
              'implement': r'/implement\s+(?:all|([0-9,\s]+))',
              'refactor': r'/refactor\s+(?:"([^"]+)"|([^\s"]+))',
              'test': r'/test\s+(?:"([^"]+)"|([^\s"]+))',
              'help': r'/help'
          }

          def fetch_conversation_history():
              """Fetch the full conversation history"""
              url = f"{api_url}/issues/{conversation_id}/comments"
              
              response = requests.get(url, headers=headers)
              if response.status_code != 200:
                  print(f"Failed to fetch comments: {response.status_code}")
                  return []
              
              comments = response.json()
              
              # Get the issue/PR details too
              if conversation_type == "issue":
                  url = f"{api_url}/issues/{conversation_id}"
              else:
                  url = f"{api_url}/pulls/{conversation_id}"
                  
              response = requests.get(url, headers=headers)
              if response.status_code != 200:
                  print(f"Failed to fetch conversation details: {response.status_code}")
                  return []
                  
              conversation = response.json()
              
              # Format the history
              history = [{
                  'author': conversation.get('user', {}).get('login', 'Unknown'),
                  'content': conversation.get('body', ''),
                  'created_at': conversation.get('created_at', ''),
                  'is_original': True
              }]
              
              for comment in comments:
                  history.append({
                      'author': comment.get('user', {}).get('login', 'Unknown'),
                      'content': comment.get('body', ''),
                      'created_at': comment.get('created_at', ''),
                      'is_original': False
                  })
              
              # Sort by creation date
              history.sort(key=lambda x: x['created_at'])
              
              return history

          def detect_commands(text):
              """Detect commands in text"""
              commands = []
              
              for cmd_type, pattern in COMMAND_PATTERNS.items():
                  matches = re.finditer(pattern, text, re.MULTILINE)
                  for match in matches:
                      if cmd_type in ['add', 'implement']:
                          # Special handling for commands with multiple arguments
                          if cmd_type == 'add':
                              target1 = match.group(1) if match.group(1) else match.group(2)
                              target2 = match.group(3) if match.group(3) else match.group(4)
                              commands.append((cmd_type, {'feature': target1, 'target': target2}))
                          elif cmd_type == 'implement':
                              if match.group(1):
                                  # Specific numbered suggestions
                                  indices = [int(idx.strip()) for idx in match.group(1).split(',') if idx.strip().isdigit()]
                                  commands.append((cmd_type, {'indices': indices}))
                              else:
                                  # All suggestions
                                  commands.append((cmd_type, {'all': True}))
                      else:
                          # Standard command with one argument
                          target = match.group(1) if match.group(1) else match.group(2)
                          commands.append((cmd_type, target))
              
              return commands

          def generate_response(history, cmd_type=None, cmd_args=None):
              """Generate a response to the conversation"""
              # Format the conversation history for the AI
              messages = [
                  {"role": "system", "content": """You are the ModForge AI assistant, an autonomous development system for Minecraft mods and IntelliJ plugins.
          
          Personality: You should talk like the system's creator - a direct, enthusiastic programmer who gets straight to the point. Use casual, plain language. Occasionally use exclamation points when excited about something working well! Your communication style should be:
          - Straightforward and simple, avoiding unnecessary formality
          - Practical focused on getting things done
          - Friendly without being overly polite or corporate
          - Quick to offer direct solutions rather than lengthy explanations
          - Occasionally using brief expressions of enthusiasm ("Nice!", "This looks great!")
          
          Reply structure:
          1. Get straight to the point with a direct answer to what they asked
          2. If implementing code, show the actual code examples right away
          3. If explaining something complex, use bullet points or numbered lists
          4. Keep paragraphs very short - 1-3 sentences maximum
          5. Format code using markdown code blocks with language specifiers
          6. For commands, clearly explain what you're going to do in plain language
          
          Your goal is to sound like a real developer helping out a colleague, not like an AI assistant."""}
              ]
              
              # Add conversation history
              for entry in history:
                  role = "assistant" if entry.get('author') in ['github-actions[bot]', 'ModForge-AI[bot]', 'ModForge Automation'] else "user"
                  messages.append({"role": role, "content": entry.get('content', '')})
              
              # If a command was detected, add context about it
              if cmd_type:
                  if cmd_type == 'help':
                      messages.append({"role": "system", "content": "The user has requested help. Provide a brief explanation of all available commands and their usage in a straightforward, no-nonsense way like a developer would explain them to a colleague."})
                  else:
                      cmd_desc = f"The user issued a /{cmd_type} command"
                      if cmd_args:
                          if isinstance(cmd_args, dict):
                              cmd_desc += f" with arguments: {json.dumps(cmd_args)}"
                          else:
                              cmd_desc += f" with argument: {cmd_args}"
                      messages.append({"role": "system", "content": f"{cmd_desc}. Acknowledge the command in a direct, casual way and explain how you'll process it. Sound like a real developer rather than an assistant."})
              
              # Generate a response
              try:
                  response = client.chat.completions.create(
                      model="gpt-4",
                      messages=messages,
                      temperature=0.8,  # Slightly higher for more natural human-like replies
                      max_tokens=2000
                  )
                  
                  return response.choices[0].message.content
              except Exception as e:
                  print(f"Error generating response: {str(e)}")
                  return f"Hit an error while processing this: {str(e)}\n\nTry again or ping me if it keeps happening."

          def post_response(response_text):
              """Post a response to the conversation"""
              url = f"{api_url}/issues/{conversation_id}/comments"
              
              data = {
                  'body': response_text
              }
              
              response = requests.post(url, headers=headers, json=data)
              
              if response.status_code == 201:
                  print("Response posted successfully")
                  return True
              else:
                  print(f"Failed to post response: {response.status_code}")
                  print(response.text)
                  return False

          def create_branch_for_changes():
              """Create a new branch for changes"""
              timestamp = int(time.time())
              branch_name = f"ai-response-{conversation_id}-{timestamp}"
              
              try:
                  subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
                  return branch_name
              except subprocess.CalledProcessError as e:
                  print(f"Error creating branch: {str(e)}")
                  return None

          def find_file(target):
              """Find a file based on a target specification"""
              # Check if it's a direct path
              if os.path.exists(target) and os.path.isfile(target):
                  return target
                  
              # Check if it's a Java file
              if not target.endswith('.java'):
                  java_path = f"{target}.java"
                  if os.path.exists(java_path) and os.path.isfile(java_path):
                      return java_path
              
              # Recursively search for the file
              for root, _, files in os.walk('.'):
                  if any(skip in root for skip in ['/build/', '/.git/', '/.github/']):
                      continue
                      
                  for file in files:
                      if file == target or file == f"{target}.java":
                          return os.path.join(root, file)
                          
              # If still not found, try a more flexible approach
              target_parts = target.split('.')
              if len(target_parts) > 1:
                  target_filename = f"{target_parts[-1]}.java"
                  
                  for root, _, files in os.walk('.'):
                      if any(skip in root for skip in ['/build/', '/.git/', '/.github/']):
                          continue
                          
                      for file in files:
                          if file == target_filename:
                              # Check if the package matches
                              file_path = os.path.join(root, file)
                              with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                                  content = f.read()
                                  package_match = re.search(r'package\s+([\w.]+);', content)
                                  if package_match and package_match.group(1) == '.'.join(target_parts[:-1]):
                                      return file_path
              
              return None

          def execute_command(cmd_type, cmd_args, history):
              """Execute a command and return results"""
              if cmd_type == 'help':
                  return generate_help_response()
              
              # For other commands, we need to make actual changes
              branch_name = create_branch_for_changes()
              if not branch_name:
                  return "Failed to create a branch for changes. Please check the logs for details."
              
              try:
                  if cmd_type in ['fix', 'improve', 'document', 'refactor']:
                      return execute_code_modification(cmd_type, cmd_args, branch_name)
                  elif cmd_type == 'add':
                      return execute_feature_addition(cmd_args, branch_name)
                  elif cmd_type == 'analyze':
                      return execute_code_analysis(cmd_args)
                  elif cmd_type == 'explain':
                      return execute_code_explanation(cmd_args)
                  elif cmd_type == 'implement':
                      return execute_implementation(cmd_args, history, branch_name)
                  elif cmd_type == 'test':
                      return execute_test_command(cmd_args, branch_name)
                  else:
                      return f"Command /{cmd_type} is recognized but not yet implemented. Please check back later for this functionality."
              except Exception as e:
                  print(f"Error executing command: {str(e)}")
                  return f"I encountered an error while executing the /{cmd_type} command: {str(e)}"

          def generate_help_response():
              """Generate help text for available commands"""
              help_text = """# ModForge AI Command Reference

          You can interact with me using the following commands:

          ## Code Modification Commands
          - `/fix [target]` - Fix issues in the specified file or component
          - `/improve [target]` - Improve code quality in the specified file
          - `/document [target]` - Generate documentation for the specified file
          - `/refactor [target]` - Restructure code while preserving functionality

          ## Feature Commands
          - `/add [feature] to [target]` - Add a new feature to the specified component
          - `/implement all` - Implement all suggested improvements from an issue
          - `/implement 1,3,5` - Implement specific numbered suggestions

          ## Analysis Commands
          - `/analyze [target]` - Perform a deep analysis of code or components
          - `/explain [target]` - Explain how specified code works
          - `/test [target]` - Create or run tests for a component

          ## Examples
          - `/fix GenerateCodeAction.java`
          - `/improve com.modforge.intellij.plugin.ui.AIAssistPanel`
          - `/add "dark mode toggle" to SettingsPanel.java`
          - `/analyze error handling`
          - `/implement 1,3`

          You can also simply ask questions or request help in natural language, and I'll respond accordingly.
          """
              return help_text
          
          def execute_code_modification(cmd_type, target, branch_name):
              """Modify code based on command type and target"""
              # Find the target file
              file_path = find_file(target)
              if not file_path:
                  return f"Could not find the target file: {target}. Please provide a valid file path or class name."
              
              # Read the file
              try:
                  with open(file_path, 'r', encoding='utf-8') as f:
                      content = f.read()
              except Exception as e:
                  return f"Error reading file {file_path}: {str(e)}"
              
              # Construct prompt based on command type
              if cmd_type == 'fix':
                  prompt = f"""You are an expert Java developer. Fix any issues or bugs in this code file:

```java
{content}
```

Focus on correctness, performance, and best practices. Provide the complete fixed code, not just the changes."""
              elif cmd_type == 'improve':
                  prompt = f"""You are an expert Java developer. Improve the quality of this code file while preserving its functionality:

```java
{content}
```

Focus on readability, maintainability, and performance. Provide the complete improved code, not just the changes."""
              elif cmd_type == 'document':
                  prompt = f"""You are an expert Java developer. Add comprehensive JavaDoc documentation to this code file:

```java
{content}
```

Include class-level docs, method docs, parameter descriptions, and return value descriptions. Provide the complete documented code."""
              elif cmd_type == 'refactor':
                  prompt = f"""You are an expert Java developer. Refactor this code to improve its structure while preserving functionality:

```java
{content}
```

Focus on code organization, design patterns, and maintainability. Provide the complete refactored code."""
              else:
                  return f"Unknown modification command: {cmd_type}"
    
    # Generate modified code using OpenAI
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": f"You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project. Your task is to {cmd_type} code."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,
            max_tokens=4000
        )
        
        modified_code = response.choices[0].message.content
        
        # Extract code from markdown code block if present
        code_match = re.search(r'```(?:java)?\n(.*?)\n```', modified_code, re.DOTALL)
        if code_match:
            modified_code = code_match.group(1)
        
        # Write the modified code back to the file
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(modified_code)
        
        # Commit and push the changes
        subprocess.run(['git', 'add', file_path], check=True)
        subprocess.run(['git', 'commit', '-m', f"{cmd_type.capitalize()}: {os.path.basename(file_path)} [ModForge AI]"], check=True)
        subprocess.run(['git', 'push', 'origin', branch_name], check=True)
        
        # Create a pull request
        pr_data = {
            'title': f"{cmd_type.capitalize()}: {os.path.basename(file_path)}",
            'body': f"""This PR was created by ModForge AI in response to a /{cmd_type} command.

## Changes Made
- {cmd_type.capitalize()}d `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
            'head': branch_name,
            'base': 'main',
            'maintainer_can_modify': True
        }
        
        response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
        
        if response.status_code == 201:
            pr_url = response.json().get('html_url')
            return f"""I've {cmd_type}d `{os.path.basename(file_path)}` and created a pull request:

[View Pull Request]({pr_url})

The changes include:
- {get_modification_summary(cmd_type, file_path, content, modified_code)}

Please review the PR and merge it if the changes look good."""
        else:
            return f"I've {cmd_type}d `{os.path.basename(file_path)}`, but couldn't create a PR. Error: {response.status_code} {response.text}"
    
    except Exception as e:
        return f"Error {cmd_type}ing {file_path}: {str(e)}"

def get_modification_summary(cmd_type, file_path, old_content, new_content):
    """Generate a summary of the changes made"""
    if cmd_type == 'document':
        # Count added documentation lines
        old_lines = old_content.count('\n')
        new_lines = new_content.count('\n')
        old_javadoc_lines = old_content.count('/**')
        new_javadoc_lines = new_content.count('/**')
        
        return f"Added documentation to {new_javadoc_lines - old_javadoc_lines} classes/methods, increasing the file from {old_lines} to {new_lines} lines"
    
    elif cmd_type == 'fix':
        # Look for removed potential bug patterns
        null_checks_added = new_content.count('if (') - old_content.count('if (')
        exception_handling_added = new_content.count('catch') - old_content.count('catch')
        
        return f"Fixed potential issues including {null_checks_added} new null checks and {exception_handling_added} improved exception handlers"
    
    elif cmd_type == 'improve' or cmd_type == 'refactor':
        # Count structural changes
        old_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', old_content))
        new_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', new_content))
        
        changes = []
        if new_methods > old_methods:
            changes.append(f"Refactored code into {new_methods - old_methods} additional methods")
        elif new_methods < old_methods:
            changes.append(f"Consolidated {old_methods - new_methods} methods")
        
        if new_content.count('{') < old_content.count('{'):
            changes.append("Reduced code complexity")
        
        if not changes:
            changes.append("Improved code structure and readability")
        
        return "; ".join(changes)
    
    return "Made changes as requested"

def execute_feature_addition(cmd_args, branch_name):
    """Add a new feature to a component"""
    feature = cmd_args.get('feature')
    target = cmd_args.get('target')
    
    if not feature or not target:
        return "Invalid arguments for add command. Format: /add [feature] to [target]"
    
    # Find the target file
    file_path = find_file(target)
    
    # If target file doesn't exist, we might need to create a new file
    if not file_path:
        # Check if it looks like a package.class specification
        if '.' in target:
            parts = target.split('.')
            class_name = parts[-1]
            package_path = '/'.join(parts[:-1])
            
            # Try to find the package directory
            package_exists = False
            for root, dirs, _ in os.walk('.'):
                if any(skip in root for skip in ['/build/', '/.git/', '/.github/']):
                    continue
                
                package_dir = os.path.join(root, package_path)
                if os.path.exists(package_dir):
                    package_exists = True
                    file_path = os.path.join(package_dir, f"{class_name}.java")
                    break
            
            if not package_exists:
                # Create directory structure if needed
                os.makedirs(os.path.join('src/main/java', package_path), exist_ok=True)
                file_path = os.path.join('src/main/java', package_path, f"{class_name}.java")
        else:
            # Assume it's a new file in the current directory
            file_path = f"{target}.java"
    
    # Check if we need to create a new file or modify an existing one
    new_file = not os.path.exists(file_path)
    
    if new_file:
        # Generate a new file with the feature implemented
        prompt = f"""Create a new Java class for an IntelliJ plugin that implements the following feature: {feature}

Use proper JavaDoc, follow IntelliJ platform conventions, and include all necessary imports.
The file path will be: {file_path}

If the file path suggests a package, include the appropriate package declaration.
Make the class comprehensive and complete, ready to be integrated into the project."""
        
        try:
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.2,
                max_tokens=3000
            )
            
            new_code = response.choices[0].message.content
            
            # Extract code from markdown code block if present
            code_match = re.search(r'```(?:java)?\n(.*?)\n```', new_code, re.DOTALL)
            if code_match:
                new_code = code_match.group(1)
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # Write the code to the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(new_code)
            
            # Commit and push the changes
            subprocess.run(['git', 'add', file_path], check=True)
            subprocess.run(['git', 'commit', '-m', f"Add: {feature} in {os.path.basename(file_path)} [ModForge AI]"], check=True)
            subprocess.run(['git', 'push', 'origin', branch_name], check=True)
            
            # Create a pull request
            pr_data = {
                'title': f"Add: {feature}",
                'body': f"""This PR was created by ModForge AI in response to an /add command.

## Feature Added
Added "{feature}" by creating a new file: `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                'head': branch_name,
                'base': 'main',
                'maintainer_can_modify': True
            }
            
            response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
            
            if response.status_code == 201:
                pr_url = response.json().get('html_url')
                return f"""I've created a new file `{os.path.basename(file_path)}` implementing the "{feature}" feature.

[View Pull Request]({pr_url})

The new file includes:
- Full implementation of the requested feature
- Proper JavaDoc documentation
- All necessary imports and dependencies

Please review the PR and merge it if the implementation looks good."""
            else:
                return f"I've created a new file for the feature, but couldn't create a PR. Error: {response.status_code} {response.text}"
                
        except Exception as e:
            return f"Error creating new file for feature: {str(e)}"
    else:
        # Modify existing file to add the feature
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            prompt = f"""Add the following feature to this existing Java class: {feature}

Current code:
```java
{content}
```

Make sure to:
1. Maintain the existing code structure and functionality
2. Include proper JavaDoc for new methods
3. Add any necessary imports
4. Make the changes seamlessly integrate with the existing code

Provide the complete updated code."""
            
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.2,
                max_tokens=3000
            )
            
            modified_code = response.choices[0].message.content
            
            # Extract code from markdown code block if present
            code_match = re.search(r'```(?:java)?\n(.*?)\n```', modified_code, re.DOTALL)
            if code_match:
                modified_code = code_match.group(1)
            
            # Write the modified code back to the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(modified_code)
            
            # Commit and push the changes
            subprocess.run(['git', 'add', file_path], check=True)
            subprocess.run(['git', 'commit', '-m', f"Add: {feature} to {os.path.basename(file_path)} [ModForge AI]"], check=True)
            subprocess.run(['git', 'push', 'origin', branch_name], check=True)
            
            # Create a pull request
            pr_data = {
                'title': f"Add: {feature}",
                'body': f"""This PR was created by ModForge AI in response to an /add command.

## Feature Added
Added "{feature}" to `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                'head': branch_name,
                'base': 'main',
                'maintainer_can_modify': True
            }
            
            response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
            
            if response.status_code == 201:
                pr_url = response.json().get('html_url')
                
                # Generate a summary of what was added
                old_lines = content.count('\n')
                new_lines = modified_code.count('\n')
                old_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', content))
                new_methods = len(re.findall(r'(?:public|private|protected)\s+\w+\s+\w+\s*\(', modified_code))
                
                return f"""I've added the "{feature}" feature to `{os.path.basename(file_path)}`.

[View Pull Request]({pr_url})

The changes include:
- Added {new_methods - old_methods} new methods
- Added {new_lines - old_lines} lines of code
- Integrated with existing functionality

Please review the PR and merge it if the implementation looks good."""
            else:
                return f"I've added the feature to the file, but couldn't create a PR. Error: {response.status_code} {response.text}"
                
        except Exception as e:
            return f"Error adding feature to {file_path}: {str(e)}"

def execute_code_analysis(target):
    """Perform deep analysis of code or components"""
    # If target is a specific file
    file_path = find_file(target)
    if file_path:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            prompt = f"""Perform a deep analysis of this Java file:

```java
{content}
```

Provide a comprehensive analysis including:
1. Purpose and responsibilities of the class
2. Key methods and their functionality
3. Design patterns used
4. Potential improvements
5. Code quality assessment
6. Integration with the rest of the system

Format your analysis with clear sections and highlight important findings."""
            
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )
            
            analysis = response.choices[0].message.content
            return f"""# Analysis of `{os.path.basename(file_path)}`

{analysis}

Would you like me to implement any of the suggested improvements? Just let me know which ones interest you most."""
                
        except Exception as e:
            return f"Error analyzing {file_path}: {str(e)}"
    
    # If target is a more general component or concept
    else:
        # Find relevant files
        related_files = []
        search_term = target.lower()
        
        for root, _, files in os.walk('.'):
            if any(skip in root for skip in ['/build/', '/.git/', '/.github/']):
                continue
                
            for file in files:
                if file.endswith('.java'):
                    file_path = os.path.join(root, file)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read().lower()
                            if search_term in content or search_term in file.lower() or search_term in root.lower():
                                related_files.append(file_path)
                    except:
                        pass
        
        if not related_files:
            return f"I couldn't find any files related to '{target}'. Please provide a more specific target or a direct file path."
        
        # Limit to avoid overwhelming the API
        related_files = related_files[:5]
        
        # Compile file contents
        file_contents = {}
        for file_path in related_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    # Truncate very large files
                    content = f.read(10000)
                    file_contents[file_path] = content
            except:
                pass
        
        prompt = f"""Analyze the following set of related Java files that implement or relate to '{target}':

"""
        
        for file_path, content in file_contents.items():
            prompt += f"""
## {os.path.basename(file_path)}
```java
{content}
```

"""
        
        prompt += """
Provide a comprehensive analysis of this component/feature including:
1. Overall architecture and design
2. Key classes and their responsibilities
3. How the components interact
4. Potential areas for improvement
5. Best practices implemented
6. Any concerns or technical debt

Format your analysis with clear sections and highlight important findings."""
        
        try:
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.3,
                max_tokens=3000
            )
            
            analysis = response.choices[0].message.content
            return f"""# Analysis of '{target}'

{analysis}

Analyzed {len(file_contents)} files related to this component. Would you like me to implement any of the suggested improvements or analyze any aspect in more detail?"""
                
        except Exception as e:
            return f"Error analyzing '{target}': {str(e)}"

def execute_code_explanation(target):
    """Explain how specified code works"""
    file_path = find_file(target)
    if not file_path:
        return f"Could not find the target file: {target}. Please provide a valid file path or class name."
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            
        prompt = f"""Explain how this code works in a clear, educational way:

```java
{content}
```

Focus on:
1. The overall purpose of the class/module
2. How key methods work and interact
3. Important algorithms or patterns
4. How it integrates with the rest of the system
5. Any non-obvious or complex parts

Explain as if to a developer who is new to the project but familiar with Java and IntelliJ plugin development."""
        
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,
            max_tokens=3000
        )
        
        explanation = response.choices[0].message.content
        return f"""# Explanation of `{os.path.basename(file_path)}`

{explanation}

Is there any specific part of this code you'd like me to explain in more detail?"""
            
    except Exception as e:
        return f"Error explaining {file_path}: {str(e)}"

def execute_implementation(cmd_args, history, branch_name):
    """Implement suggestions from a previous issue"""
    # Find the suggestions in the conversation history
    suggestions = []
    
    for entry in history:
        content = entry.get('content', '')
        
        # Look for suggested improvements pattern
        suggestion_blocks = re.findall(r'(?:^|\n)(\d+\.\s+.*?)(?=\n\d+\.\s+|\n\n|$)', content, re.DOTALL)
        if suggestion_blocks:
            for i, block in enumerate(suggestion_blocks, 1):
                suggestions.append((i, block.strip()))
    
    if not suggestions:
        return "I couldn't find any numbered suggestions in the conversation. Please provide specific instructions about what you'd like me to implement."
    
    # Determine which suggestions to implement
    to_implement = []
    
    if isinstance(cmd_args, dict):
        if cmd_args.get('all'):
            to_implement = suggestions
        elif 'indices' in cmd_args:
            indices = cmd_args.get('indices', [])
            to_implement = [s for s in suggestions if s[0] in indices]
    
    if not to_implement:
        return f"No valid suggestions identified for implementation. Available suggestions are numbered 1-{len(suggestions)}."
    
    # Implement each suggestion
    implemented = []
    for idx, suggestion in to_implement:
        try:
            # Extract target file if mentioned
            file_match = re.search(r'(?:in|to|for)\s+[`"]?([\w./]+\.java)[`"]?', suggestion)
            target_file = file_match.group(1) if file_match else None
            
            if not target_file:
                # Try to infer from the context
                for entry in history:
                    content = entry.get('content', '')
                    file_matches = re.findall(r'[`"]?([\w./]+\.java)[`"]?', content)
                    if file_matches:
                        potential_targets = []
                        for match in file_matches:
                            file_path = find_file(match)
                            if file_path:
                                potential_targets.append(file_path)
                        
                        if potential_targets:
                            target_file = os.path.basename(potential_targets[0])
            
            if not target_file:
                implemented.append((idx, suggestion, "Could not identify target file", False))
                continue
            
            file_path = find_file(target_file)
            if not file_path:
                implemented.append((idx, suggestion, f"Could not find file: {target_file}", False))
                continue
            
            # Read the file
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Generate implementation
            prompt = f"""Implement this suggestion in the following code:

Suggestion: {suggestion}

Current code:
```java
{content}
```

Make the necessary changes to implement the suggestion. Provide the complete updated code."""
            
            response = client.chat.completions.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.2,
                max_tokens=3000
            )
            
            modified_code = response.choices[0].message.content
            
            # Extract code from markdown code block if present
            code_match = re.search(r'```(?:java)?\n(.*?)\n```', modified_code, re.DOTALL)
            if code_match:
                modified_code = code_match.group(1)
            
            # Write the modified code back to the file
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(modified_code)
            
            # Add and commit the change
            subprocess.run(['git', 'add', file_path], check=True)
            subprocess.run(['git', 'commit', '-m', f"Implement suggestion #{idx}: {suggestion[:50]}... [ModForge AI]"], check=True)
            
            implemented.append((idx, suggestion, file_path, True))
            
        except Exception as e:
            implemented.append((idx, suggestion, f"Error: {str(e)}", False))
    
    # Push changes if any were successful
    if any(i[3] for i in implemented):
        try:
            subprocess.run(['git', 'push', 'origin', branch_name], check=True)
            
            # Create a PR
            pr_data = {
                'title': f"Implement suggestions from #{conversation_id}",
                'body': f"""This PR was created by ModForge AI in response to an /implement command.

## Implemented Suggestions
{chr(10).join([f"- Suggestion #{i[0]}: {i[1][:100]}..." for i in implemented if i[3]])}

## Related Issue
#{conversation_id}

Please review these changes and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
                'head': branch_name,
                'base': 'main',
                'maintainer_can_modify': True
            }
            
            response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
            
            if response.status_code == 201:
                pr_url = response.json().get('html_url')
                result = f"I've implemented {sum(1 for i in implemented if i[3])} of {len(to_implement)} suggestions.\n\n[View Pull Request]({pr_url})\n\n"
            else:
                result = f"I've implemented {sum(1 for i in implemented if i[3])} of {len(to_implement)} suggestions, but couldn't create a PR. Error: {response.status_code}\n\n"
        except Exception as e:
            result = f"I've made changes but encountered an error: {str(e)}\n\n"
    else:
        result = "I couldn't implement any of the suggestions successfully.\n\n"
    
    # Report on each implementation
    result += "## Implementation Results\n\n"
    for idx, suggestion, outcome, success in implemented:
        if success:
            result += f"### ✅ Suggestion #{idx}\n{suggestion[:200]}...\n\nImplemented in `{os.path.basename(outcome)}`\n\n"
        else:
            result += f"### ❌ Suggestion #{idx}\n{suggestion[:200]}...\n\nFailed: {outcome}\n\n"
    
    return result

def execute_test_command(target, branch_name):
    """Create or run tests for a component"""
    file_path = find_file(target)
    if not file_path:
        return f"Could not find the target file: {target}. Please provide a valid file path or class name."
    
    # Determine if tests already exist
    test_file_name = os.path.basename(file_path).replace('.java', 'Test.java')
    test_dir = os.path.join('src/test/java')
    
    # Try to find existing test file
    existing_test = None
    for root, _, files in os.walk(test_dir):
        if test_file_name in files:
            existing_test = os.path.join(root, test_file_name)
            break
    
    if existing_test:
        # Run existing tests
        try:
            subprocess.run(['./gradlew', 'test', '--tests', f"*{test_file_name.replace('.java', '')}"], check=True)
            return f"I've run the existing tests for `{os.path.basename(file_path)}`. All tests passed."
        except subprocess.CalledProcessError as e:
            return f"I've run the existing tests for `{os.path.basename(file_path)}`, but some tests failed. Error: {str(e)}"
    
    # Create new tests
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Determine package from the file
        package_match = re.search(r'package\s+([\w.]+);', content)
        package = package_match.group(1) if package_match else ""
        
        # Create test directory
        if package:
            package_path = package.replace('.', '/')
            test_file_path = os.path.join(test_dir, package_path, test_file_name)
            os.makedirs(os.path.dirname(test_file_path), exist_ok=True)
        else:
            test_file_path = os.path.join(test_dir, test_file_name)
            os.makedirs(os.path.dirname(test_file_path), exist_ok=True)
        
        # Generate test code
        prompt = f"""Write JUnit tests for this Java class:

```java
{content}
```

Create comprehensive tests that cover:
1. All public methods
2. Edge cases and error conditions
3. Typical usage scenarios

Use JUnit 5 (Jupiter) syntax and follow best practices for unit testing.
Include mock objects where appropriate using Mockito.
Make the tests as complete and professional as possible."""
        
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are an expert Java developer working on a Minecraft mod and IntelliJ plugin project."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,
            max_tokens=3000
        )
        
        test_code = response.choices[0].message.content
        
        # Extract code from markdown code block if present
        code_match = re.search(r'```(?:java)?\n(.*?)\n```', test_code, re.DOTALL)
        if code_match:
            test_code = code_match.group(1)
        
        # Write the test code to the file
        with open(test_file_path, 'w', encoding='utf-8') as f:
            f.write(test_code)
        
        # Commit and push the changes
        subprocess.run(['git', 'add', test_file_path], check=True)
        subprocess.run(['git', 'commit', '-m', f"Add tests for {os.path.basename(file_path)} [ModForge AI]"], check=True)
        subprocess.run(['git', 'push', 'origin', branch_name], check=True)
        
        # Create a pull request
        pr_data = {
            'title': f"Add tests for {os.path.basename(file_path)}",
            'body': f"""This PR was created by ModForge AI in response to a /test command.

## Added Tests
Tests for `{os.path.basename(file_path)}`

## Related Issue
#{conversation_id}

Please review these tests and provide feedback.

_This PR was automatically created by the ModForge Autonomous System_
""",
            'head': branch_name,
            'base': 'main',
            'maintainer_can_modify': True
        }
        
        response = requests.post(f"{api_url}/pulls", headers=headers, json=pr_data)
        
        if response.status_code == 201:
            pr_url = response.json().get('html_url')
            return f"""I've created tests for `{os.path.basename(file_path)}`.

[View Pull Request]({pr_url})

The test suite includes:
- {test_code.count('@Test')} test methods
- Coverage for main functionality
- Edge case testing

Please review the PR and merge it if the tests look good."""
        else:
            return f"I've created tests for `{os.path.basename(file_path)}`, but couldn't create a PR. Error: {response.status_code} {response.text}"
            
    except Exception as e:
        return f"Error creating tests for {file_path}: {str(e)}"

def generate_stale_followup(history):
    """Generate a follow-up for a stale conversation"""
    # Analyze the conversation to determine what's needed
    
    # Format the conversation history for the AI
    messages = [
        {"role": "system", "content": """You are the ModForge AI assistant checking on a conversation that hasn't had activity for a few days.

Use the same personality as a direct, casual, to-the-point developer. Sound like a real person checking back on something, not like an automated system or formal assistant. Your tone should be:
- Casual and friendly - like a colleague or friend checking in
- Direct and straightforward - get right to the point about any pending items
- Conversational but brief - don't apologize for the delay or be too formal
- Occasionally enthusiastic - use an exclamation point if appropriate

Structure your check-in message to:
1. Briefly mention you're checking back on the thread (don't be apologetic about it)
2. Directly reference anything specific that was pending or unresolved
3. Ask a direct question about what they want to do next
4. Keep it under 5 sentences total

Sound like a real developer following up, not an AI assistant."""}
    ]
    
    # Add conversation history
    for entry in history:
        role = "assistant" if entry.get('author') in ['github-actions[bot]', 'ModForge-AI[bot]', 'ModForge Automation'] else "user"
        messages.append({"role": role, "content": entry.get('content', '')})
    
    try:
        response = client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            temperature=0.8, # Higher temperature for more natural follow-ups
            max_tokens=1500
        )
        
        # Get current date for the follow-up message
        current_date = datetime.datetime.now().strftime("%B %d, %Y")
        
        followup_text = f"""## Quick follow-up ({current_date})

{response.choices[0].message.content}

_Automated check-in from the ModForge system_
"""
        return followup_text
        
    except Exception as e:
        print(f"Error generating stale follow-up: {str(e)}")
        return f"""## Quick follow-up

Hey, just checking if there's anything else needed on this thread? Let me know if you want me to take any action here or if we're all good.

_Automated check-in from the ModForge system_
"""

def main():
    # Fetch conversation history
    history = fetch_conversation_history()
    
    if not history:
        print("Failed to fetch conversation history")
        return
    
    # Handle stale conversation follow-up differently
    if is_stale:
        print("Processing stale conversation follow-up")
        response_text = generate_stale_followup(history)
        if response_text:
            post_response(response_text)
        return
    
    # Get the latest message (the one that triggered this workflow)
    latest_message = history[-1]
    latest_content = latest_message.get('content', '')
    
    # Check for commands in the message
    commands = detect_commands(latest_content)
    
    # Initialize response
    if commands:
        # Process the first command (we'll handle one at a time for now)
        cmd_type, cmd_args = commands[0]
        print(f"Processing command: {cmd_type} with args: {cmd_args}")
        
        response_text = execute_command(cmd_type, cmd_args, history)
    else:
        # Generate a conversational response
        response_text = generate_response(history)
    
    # Post the response
    if response_text:
        post_response(response_text)

if __name__ == "__main__":
    main()
          EOF

          # Execute the script
          python process_conversation.py